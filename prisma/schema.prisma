generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum OrderSide {
  BUY
  SELL
}

enum OrderStatus {
  PENDING
  COMPLETED
  CANCELLED
}

model Order {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Compatibilidad y nuevo modelo de canales
  paymentChannelKey String?              // legacy (compat)
  paymentChannelId  String?              // nueva relación opcional
  paymentChannel    PaymentChannel?      @relation(fields: [paymentChannelId], references: [id])

  // Operación
  side       OrderSide?
  to         String                       // Ej: "USDT - TRC20"
  platform   String?                      // Ej: "PayPal" (si quieres mantenerlo)

  // Montos y snapshots
  amount               Float
  finalUsd             Float
  finalUsdt            Float
  finalCommission      Float            @default(0)
  appliedCommissionPct Float?
  appliedFixedFee      Float?
  exchangeRateUsed     Float?
  profit               Float?
  // La columna existe en DB; si no la usas, ignórala, pero conserva el map para integridad.
  realProfit           Float?           @map("realProfit") @ignore

  // Operativo
  paypalEmail     String?
  wallet          String?
  paypalInvoiceId String?

  // Estado y trazabilidad
  status    OrderStatus @default(PENDING)
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt

  // Relación con mensajes
  messages Message[] @relation("OrderMessages")

  // Índices útiles
  @@index([createdAt])
  @@index([status, createdAt])
  @@index([userId, createdAt])
  @@index([paymentChannelId, createdAt])
}

model PaymentChannel {
  id                    String   @id @default(cuid())
  key                   String   @unique      // "PAYPAL", "ZELLE", etc.
  label                 String               // Visible: "PayPal"

  // % por lado
  commissionBuyPercent  Float
  commissionSellPercent Float
  providerFeePercent    Float    @default(0)

  // Disponibilidad por lado
  enabledBuy            Boolean  @default(true)
  enabledSell           Boolean  @default(true)

  // Visibilidad y mensajes
  visible               Boolean  @default(true)
  statusTextBuy         String?
  statusTextSell        String?

  // Utilidades
  sortOrder             Int      @default(0)
  archivedAt            DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Back-relation
  orders                Order[]
}

model Message {
  id        String   @id @default(cuid())
  orderId   String
  order     Order    @relation("OrderMessages", fields: [orderId], references: [id], onDelete: Cascade)

  senderId  String
  sender    User     @relation("UserMessages", fields: [senderId], references: [id], onDelete: Cascade)

  content   String?  @db.Text
  imageUrl  String?  @db.Text
  createdAt DateTime @default(now())
}

model User {
  id              String            @id @default(cuid())
  clerkId         String            @unique
  email           String            @unique
  fullName        String?
  orders          Order[]
  messages        Message[]         @relation("UserMessages")
  verifications   Verification[]
  paymentMethods  PaymentMethod[]
  expoPushToken   String?

  // Referidos (self-relation)
  referrerId       String?
  referrer         User?            @relation("UserReferrals", fields: [referrerId], references: [id])
  referrals        User[]           @relation("UserReferrals")

  // Ganancias por referidos
  referralEarnings ReferralEarning[]
  // Back-relation para referredUser en ReferralEarning
  referredUsers    ReferralEarning[] @relation("ReferredUsers")
}

model ReferralEarning {
  id             String   @id @default(cuid())
  userId         String   // quien gana la comisión
  referredUserId String   // quien generó la orden
  amount         Float    @default(5.0)
  createdAt      DateTime @default(now())

  user         User @relation(fields: [userId], references: [id])
  referredUser User @relation("ReferredUsers", fields: [referredUserId], references: [id])
}

model ExchangeRate {
  id        String   @id @default(cuid())
  currency  String   @unique   // "BS", "COP", etc.
  rate      Float               // LEGACY
  buyRate   Float?              // Tasa para BUY
  sellRate  Float?              // Tasa para SELL
  updatedAt DateTime @updatedAt
}

model Verification {
  id          String   @id @default(cuid())
  userId      String   @unique
  documentUrl String
  selfieUrl   String
  status      String   @default("PENDING") // PENDING, APPROVED, REJECTED
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])
}

model PaymentMethod {
  id        String   @id @default(cuid())
  userId    String
  type      String   // "PayPal", "PagoMovil", "USDT", etc.
  details   Json     // Objeto dinámico según el tipo
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}
